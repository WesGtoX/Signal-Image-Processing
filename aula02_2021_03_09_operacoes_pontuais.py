# -*- coding: utf-8 -*-
"""aula02_2021-03-09_operacoes_pontuais.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IRnPdiXES-n8fcDzyJDKwqlOyD0MnWJU

# **Processamento de Imagens e Imagens**
Engenharia da Computação - 2021.01

## Operações Pontuais

### Download das imagens de teste
"""

!wget 'https://homepages.cae.wisc.edu/~ece533/images/peppers.png'
!wget 'https://homepages.cae.wisc.edu/~ece533/images/baboon.png'

"""### Imports"""

import cv2 as cv
import matplotlib.pyplot as plt

"""### Code"""

img1 = cv.imread('peppers.png')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = cv.imread('baboon.png')
img2 = cv.cvtColor(img2, cv.COLOR_BGR2RGB)

img3 = cv.add(img1, 60)
img4 = cv.add(img1, img2)
img5 = cv.bitwise_not(img2)
img6 = cv.bitwise_and(img1, img2)
img7 = cv.bitwise_or(img1, img2)
img8 = cv.bitwise_xor(img1, img2)
img9 = cv.subtract(img1, img2)
img10 = cv.addWeighted(img1, 0.60, img2, 0.80, 0)

plt.figure(figsize=(16, 14))
plt.subplot(551), plt.imshow(img1)
plt.subplot(552), plt.imshow(img2)
plt.subplot(553), plt.imshow(img3)
plt.subplot(554), plt.imshow(img4)
plt.subplot(555), plt.imshow(img5)
plt.subplot(556), plt.imshow(img6)
plt.subplot(557), plt.imshow(img7)
plt.subplot(558), plt.imshow(img8)
plt.subplot(559), plt.imshow(img9)
plt.subplot(5,5,10), plt.imshow(img10)

plt.show()

"""### Exercises

#### Imports
"""

import numpy as np

"""#### Code

1. Utilizando a biblioteca OpenCV construa uma aplicação para:  
    - Carregar uma imagem digital  
    - Separar e apresentar os canais da imagem
"""

img_origin = cv.imread('peppers.png')
img_origin = cv.cvtColor(img_origin, cv.COLOR_BGR2RGB)

blue_channel, green_channel, red_channel = cv.split(img_origin)
zeros = np.zeros(img_origin.shape[:2], dtype = 'uint8')

red = cv.merge([red_channel, zeros, zeros])
green = cv.merge([zeros, green_channel, zeros])
blue = cv.merge([zeros, zeros, blue_channel])

plt.figure(figsize=(16, 14))
plt.subplot(551), plt.imshow(img_origin)
plt.subplot(552), plt.imshow(red), plt.title('red')
plt.subplot(553), plt.imshow(green), plt.title('green')
plt.subplot(554), plt.imshow(blue), plt.title('blue')
plt.show()

"""2. Utilizando a biblioteca OpenCV construa uma aplicação para:  
    - Carregar uma imagem digital  
    - Transformar a imagem para tons de cinza utilizando operações pontuais.  
    - [Matplotlib Colormaps](https://matplotlib.org/stable/tutorials/colors/colormaps.html)
"""

img_origin = cv.imread('peppers.png')
img_origin = cv.cvtColor(img_origin, cv.COLOR_BGR2RGB)

img_gray = cv.cvtColor(img_origin, cv.COLOR_RGB2GRAY)

# coverter RGB -> Gray manualmente
img_gray_manual = img_origin.copy()
img_gray_weighted = img_origin.copy()

for row in range(img_gray_manual.shape[0]):    # para todas as linhas
    for col in range(img_gray_manual.shape[1]):    # para todas as colunas
        r = img_gray_manual.item(row, col, 0)  # valor do pixel R
        g = img_gray_manual.item(row, col, 1)  # valor do pixel G
        b = img_gray_manual.item(row, col, 2)  # valor do pixel B
        gray = (r + g + b) / 3  # formula de conversao
        gray_weighted = (r * 0.30) + (g * 0.59) + (b * 0.11)  # formula de conversao ponderada

        # alterar os pixels da imagem
        img_gray_manual.itemset((row, col, 0), gray)
        img_gray_manual.itemset((row, col, 1), gray)
        img_gray_manual.itemset((row, col, 2), gray)

        img_gray_weighted.itemset((row, col, 0), gray_weighted)
        img_gray_weighted.itemset((row, col, 1), gray_weighted)
        img_gray_weighted.itemset((row, col, 2), gray_weighted)

plt.figure(figsize=(10, 10))
plt.subplot(141), plt.imshow(img_origin), plt.title('original')
plt.subplot(142), plt.imshow(img_gray, cmap='gray'), plt.title('gray')
plt.subplot(143), plt.imshow(img_gray_manual, cmap='gray'), plt.title('gray manual')
plt.subplot(144), plt.imshow(img_gray_weighted, cmap='gray'), plt.title('gray weighted')
plt.show()

"""3. Utilizando a biblioteca OpenCV construa uma aplicação para:  
    - Carregar uma imagem digital  
    - Transformar a imagem para preto e branco (binária) utilizando operações pontuais.  
"""

img_bwb = img_gray.copy()

for row in range(img_gray.shape[0]):
    for col in range(img_gray.shape[1]):
        pixel = img_gray.item(row, col)
        if pixel > 127:
            img_bwb.itemset((row, col), 255)
        else:
            img_bwb.itemset((row, col), 0)

plt.figure(figsize=(10, 10))
plt.subplot(144), plt.imshow(img_bwb, cmap='gray'), plt.title('B&W Binary')
plt.show()